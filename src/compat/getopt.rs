// Copyright (c) 1987, 1993, 1994
// The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
use crate::*;

// originally generated by c2rust
// refactored to remove the BSD prefix, we don't need to worry about collisions with C

pub static mut OPTERR: i32 = 1;
pub static mut OPTIND: i32 = 1;
pub static mut OPTOPT: u8 = 0;
pub static mut OPTRESET: i32 = 0;
pub static mut OPTARG: *mut u8 = null_mut();

pub unsafe fn getopt(mut nargc: i32, mut nargv: *const *mut u8, mut ostr: *const u8) -> Option<u8> {
    unsafe {
        static mut PLACE: *const u8 = c"".as_ptr().cast();
        let mut oli: *mut u8 = null_mut();
        if ostr.is_null() {
            return None;
        }
        if OPTRESET != 0 || *PLACE == 0 {
            OPTRESET = 0;
            if OPTIND >= nargc || {
                PLACE = *nargv.offset(OPTIND as isize);
                *PLACE != b'-'
            } {
                PLACE = c"".as_ptr().cast();
                return None;
            }
            if *PLACE.add(1) != 0 && {
                PLACE = PLACE.add(1);
                *PLACE == b'-'
            } {
                if *PLACE.add(1) != 0 {
                    return Some(b'?');
                }
                OPTIND += 1;
                OPTIND;
                PLACE = c"".as_ptr().cast();
                return None;
            }
        }
        let fresh0 = PLACE;
        PLACE = PLACE.offset(1);
        OPTOPT = *fresh0;
        if OPTOPT == b':' || {
            oli = crate::libc::strchr(ostr, OPTOPT as i32);
            oli.is_null()
        } {
            if OPTOPT == b'-' {
                return None;
            }
            if *PLACE == 0 {
                OPTIND += 1;
                OPTIND;
            }
            if OPTERR != 0 && *ostr != b':' {
                let tmp = OPTOPT;
                eprintln!("tmux-rs: unknown option -- {}", tmp as char);
            }
            return Some(b'?');
        }
        oli = oli.offset(1);
        if *oli != b':' {
            OPTARG = null_mut();
            if *PLACE == 0 {
                OPTIND += 1;
                OPTIND;
            }
        } else {
            if *PLACE != 0 {
                OPTARG = PLACE.cast_mut();
            } else {
                OPTIND += 1;
                if nargc <= OPTIND {
                    PLACE = c"".as_ptr().cast();
                    if *ostr == b':' {
                        return Some(b':');
                    }
                    if OPTERR != 0 {
                        let tmp = OPTOPT;
                        eprintln!("tmux-rs: option requires an argument -- {}", tmp as char);
                    }
                    return Some(b'?');
                } else {
                    OPTARG = *nargv.offset(OPTIND as isize);
                }
            }
            PLACE = c"".as_ptr().cast();
            OPTIND += 1;
            OPTIND;
        }

        Some(OPTOPT)
    }
}
